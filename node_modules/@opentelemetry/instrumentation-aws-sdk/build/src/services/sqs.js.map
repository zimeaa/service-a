{"version":3,"file":"sqs.js","sourceRoot":"","sources":["../../../src/services/sqs.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {\n  Tracer,\n  SpanKind,\n  Span,\n  propagation,\n  trace,\n  context,\n  ROOT_CONTEXT,\n  Attributes,\n} from '@opentelemetry/api';\nimport { pubsubPropagation } from '@opentelemetry/propagation-utils';\nimport { RequestMetadata, ServiceExtension } from './ServiceExtension';\nimport type { SQS } from '../aws-sdk.types';\nimport {\n  AwsSdkInstrumentationConfig,\n  NormalizedRequest,\n  NormalizedResponse,\n} from '../types';\nimport {\n  MESSAGINGDESTINATIONKINDVALUES_QUEUE,\n  MESSAGINGOPERATIONVALUES_PROCESS,\n  MESSAGINGOPERATIONVALUES_RECEIVE,\n  SEMATTRS_MESSAGING_DESTINATION,\n  SEMATTRS_MESSAGING_DESTINATION_KIND,\n  SEMATTRS_MESSAGING_MESSAGE_ID,\n  SEMATTRS_MESSAGING_OPERATION,\n  SEMATTRS_MESSAGING_SYSTEM,\n  SEMATTRS_MESSAGING_URL,\n} from '@opentelemetry/semantic-conventions';\nimport {\n  contextGetter,\n  extractPropagationContext,\n  injectPropagationContext,\n  addPropagationFieldsToAttributeNames,\n} from './MessageAttributes';\n\nexport class SqsServiceExtension implements ServiceExtension {\n  requestPreSpanHook(\n    request: NormalizedRequest,\n    _config: AwsSdkInstrumentationConfig\n  ): RequestMetadata {\n    const queueUrl = this.extractQueueUrl(request.commandInput);\n    const queueName = this.extractQueueNameFromUrl(queueUrl);\n    let spanKind: SpanKind = SpanKind.CLIENT;\n    let spanName: string | undefined;\n\n    const spanAttributes: Attributes = {\n      [SEMATTRS_MESSAGING_SYSTEM]: 'aws.sqs',\n      [SEMATTRS_MESSAGING_DESTINATION_KIND]:\n        MESSAGINGDESTINATIONKINDVALUES_QUEUE,\n      [SEMATTRS_MESSAGING_DESTINATION]: queueName,\n      [SEMATTRS_MESSAGING_URL]: queueUrl,\n    };\n\n    let isIncoming = false;\n\n    switch (request.commandName) {\n      case 'ReceiveMessage':\n        {\n          isIncoming = true;\n          spanKind = SpanKind.CONSUMER;\n          spanName = `${queueName} receive`;\n          spanAttributes[SEMATTRS_MESSAGING_OPERATION] =\n            MESSAGINGOPERATIONVALUES_RECEIVE;\n\n          request.commandInput.MessageAttributeNames =\n            addPropagationFieldsToAttributeNames(\n              request.commandInput.MessageAttributeNames,\n              propagation.fields()\n            );\n        }\n        break;\n\n      case 'SendMessage':\n      case 'SendMessageBatch':\n        spanKind = SpanKind.PRODUCER;\n        spanName = `${queueName} send`;\n        break;\n    }\n\n    return {\n      isIncoming,\n      spanAttributes,\n      spanKind,\n      spanName,\n    };\n  }\n\n  requestPostSpanHook = (request: NormalizedRequest) => {\n    switch (request.commandName) {\n      case 'SendMessage':\n        {\n          const origMessageAttributes =\n            request.commandInput['MessageAttributes'] ?? {};\n          if (origMessageAttributes) {\n            request.commandInput['MessageAttributes'] =\n              injectPropagationContext(origMessageAttributes);\n          }\n        }\n        break;\n\n      case 'SendMessageBatch':\n        {\n          const entries = request.commandInput?.Entries;\n          if (Array.isArray(entries)) {\n            entries.forEach(\n              (messageParams: {\n                MessageAttributes: SQS.MessageBodyAttributeMap;\n              }) => {\n                messageParams.MessageAttributes = injectPropagationContext(\n                  messageParams.MessageAttributes ?? {}\n                );\n              }\n            );\n          }\n        }\n        break;\n    }\n  };\n\n  responseHook = (\n    response: NormalizedResponse,\n    span: Span,\n    tracer: Tracer,\n    config: AwsSdkInstrumentationConfig\n  ) => {\n    switch (response.request.commandName) {\n      case 'SendMessage':\n        span.setAttribute(\n          SEMATTRS_MESSAGING_MESSAGE_ID,\n          response?.data?.MessageId\n        );\n        break;\n\n      case 'SendMessageBatch':\n        // TODO: How should this be handled?\n        break;\n\n      case 'ReceiveMessage': {\n        const messages: SQS.Message[] = response?.data?.Messages;\n        if (messages) {\n          const queueUrl = this.extractQueueUrl(response.request.commandInput);\n          const queueName = this.extractQueueNameFromUrl(queueUrl);\n\n          pubsubPropagation.patchMessagesArrayToStartProcessSpans<SQS.Message>({\n            messages,\n            parentContext: trace.setSpan(context.active(), span),\n            tracer,\n            messageToSpanDetails: (message: SQS.Message) => ({\n              name: queueName ?? 'unknown',\n              parentContext: propagation.extract(\n                ROOT_CONTEXT,\n                extractPropagationContext(\n                  message,\n                  config.sqsExtractContextPropagationFromPayload\n                ),\n                contextGetter\n              ),\n              attributes: {\n                [SEMATTRS_MESSAGING_SYSTEM]: 'aws.sqs',\n                [SEMATTRS_MESSAGING_DESTINATION]: queueName,\n                [SEMATTRS_MESSAGING_DESTINATION_KIND]:\n                  MESSAGINGDESTINATIONKINDVALUES_QUEUE,\n                [SEMATTRS_MESSAGING_MESSAGE_ID]: message.MessageId,\n                [SEMATTRS_MESSAGING_URL]: queueUrl,\n                [SEMATTRS_MESSAGING_OPERATION]:\n                  MESSAGINGOPERATIONVALUES_PROCESS,\n              },\n            }),\n            processHook: (span: Span, message: SQS.Message) =>\n              config.sqsProcessHook?.(span, { message }),\n          });\n\n          pubsubPropagation.patchArrayForProcessSpans(\n            messages,\n            tracer,\n            context.active()\n          );\n        }\n        break;\n      }\n    }\n  };\n\n  extractQueueUrl = (commandInput: Record<string, any>): string => {\n    return commandInput?.QueueUrl;\n  };\n\n  extractQueueNameFromUrl = (queueUrl: string): string | undefined => {\n    if (!queueUrl) return undefined;\n\n    const segments = queueUrl.split('/');\n    if (segments.length === 0) return undefined;\n\n    return segments[segments.length - 1];\n  };\n}\n"]}